package com.dianchao.leetcode;

/**
 * 这个题目说的是，给你两个递增排序的数组，你要把第二个数组合并到第一个，并使其仍然保持递增排序。两个数组中的元素个数会显式地给出，并且第一个数组的大小可以容纳下两个数组中所有的元素。
 *
 * 比如说给你的两个数组是：
 *
 * 2, 4, _, _
 * 1, 3
 *
 * 它们都有 2 个元素。并且第一个数组后面有足够的空间来填充第二个数组。把第二个数组合并到第一个数组后，得到的是：
 *
 * 1, 2, 3, 4
 *
 * 思路：使用两个游标分别指向两个数组元素，然后进行对比，如果我们从下标0开始，发现把第二个数组中的元素插入到第一个数组时，插入位置后面
 * 的元素都要向后移动一个位置，这样算法的时间复杂度比较高；但是如果我们从数组的最后一个位置开始比较，则不会出现这样大量移动元素的
 * 情况，因此我们定义两个游标分别指向数组的最后元素，用k表示要插入的位置，k的初始值为2个数组长度减1
 */
public class MergeTwoSortedArray_19 {
    // Time: O(m+n), Space: O(1)
    public void mergeTwoSortedArray(int[] nums1, int m, int[] nums2, int n) {
        //定义两个游标分别指向数组的最后一个元素
        //定义变量k，表示元素待插入的位置，初始值两个数组长度-1
        int i = m - 1, j = n - 1, k = m + n - 1;
        //当游标i和j都大于等于0时，重复以下操作
        while (i >= 0 && j >= 0) {
            //如果第二个数组中的元素比较大，则将它插入到位置k，更新j和k的值向左移动一个位置
            if (nums2[j] > nums1[i])
                nums1[k--] = nums2[j--];
            else
                //如果第一个数组中的元素比较大的，则将它插入到位置k，更新i和k的值向左移动一个位置
                nums1[k--] = nums1[i--];
        }
        //循环结束，检查数组2中是否还有未比较的元素，如果有则将其都插入到第一个数组
        while (j >= 0) nums1[k--] = nums2[j--];
    }
}
